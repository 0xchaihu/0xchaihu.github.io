[{"title":"赛博考古-请回答1989：Game Boy （一）","path":"/2023/05/18/赛博考古-请回答1989：Game Boy （一）/","content":"写在前面 ：这是Game Boy考古系列的第一篇（也不知道能坚持写几篇…），将会主要介绍Game Boy的背景故事，以及硬件参数。 最近，米忽悠的星穹铁道刚上线，任天堂也在近期发布了林克塞尔达传说王国之泪。游戏爱好者可以说是提前过年了。 让我们把时钟拨回到1989年4月21日。 曾经的扑克牌大厂任天堂发布了第一款Game Boy。 与它同时发布的，还有一款游戏——日后家喻户晓的管道工人马里奥的开山之作《超级马里奥大陆》。 Game Boy的成功超乎了人们的想象，它是历史上第一台销量过亿的游戏机，它在2003年3月23日宣告停产，截止停产，共售出1.1869亿台，在游戏掌机历史销量排名中，取得了第四的好成绩（数据来自VGChartz）。无论从哪个角度看，这个产品对任天堂，甚至于游戏行业，都具有划时代的意义。（题外话：游戏掌机历史销量排名中，前十名里，有五位出自任天堂，老任恐怖如斯） 作为一个程序员，由衷地佩服三四十年前的前辈，用性能孱弱的8位机芯片，和极其有限的资源，完成了流畅的游戏动画（尽管是2-bit灰度屏），甚至还有背景音乐，并且能提供30小时的游戏时间，前辈们的英姿令人钦佩。 小时候零花钱非常有限，实力并不允许我买一台Game Boy，现在来一次赛博考古，四舍五入也算是圆梦了。 本文的所有资料都来自互联网，例如： JackTech的（系列视频） Michael Steil大神（真·大佬）的演讲（演讲） Dante Gonzales和Ian Doten的（Game Boy Architecture） Joonas Javanainen的（Game Boy: Complete Technical Reference） FH KARLSRUHE - UNIVERSITY OF TECHNOLOGY的Game Boy兴趣小组的（The Game Boy Project） 以及知乎，百度，谷歌，维基百科等等。 与其说是考古，倒不如说是拾人牙慧，以及对大佬们的拙劣总结。 Game Boy主板如下图所示： 其中位于中心位置，丝印为“DMG-CPU”的，是Game Boy的主控芯片。DMG的全称是“Dot Matrix Game”，这个缩写几乎印在了所有任天堂为Game Boy定制的芯片上。其真实型号为Sharp的LR35902（注：甚至有人使用RUST写了一个LR35902的虚拟机。遗憾的是，我目前并没有找到LR35902官方的datasheet，但是，找到了一个由爱好者编写的手册。 位于芯片右上方的，是板载的8K bytes的RAM（在老任的专利中称为Work RAM）；位于芯片右下方的，是板载的8K bytes的video RAM（在老任的专利中称为DISP RAM）。两块RAM都是Sharp的LH5264N4。 LR35902主频为4.194304 MHz（但是实际上，可以说是只有1.048576 MHz，因为机器周期为时钟周期的四分之一），单核8080 8位机架构，可以看作是Intel 8080和Zilog Z80结合后的变体，真正的集成在CPU内部的RAM只有127 bytes，在很多资料中被称为HRAM或High RAM。保守估计，现在三五块钱人民币一个肉包子钱的单片机芯片，性能应该是它的三五百倍以上。 作为对比，2017年任天堂发布的Switch采用了Nvidia的Tegra X1，最高主频为921 MHz，4核Cortex A57+4核Cortex A53，并且还有型号为GM20B Maxell的GPU。 LR35902还有256 bytes的On-CPU-Die ROM（也就是Boot ROM），用于检查游戏卡带的头部存储内容是否正确，在屏幕上播放任天堂启动动画，并播放“po-ling”声音。后续有机会的话我会单独介绍。 板子上还有一个晶振，频率为4.194304 MHz，型号为Daishinku的D419A2，可能是主板上为数不多的非夏普的器件。 在板子的右边，还有一个音频功放芯片，丝印为“DMG-AMP IR3R40 9143 A”，真实型号是Sharp的IR3R40。 位于最下方的，就是Game Boy游戏卡的插槽。 通过一条连接线，Game Boy甚至支持设备连接多人游戏功能。 我还找到了任天堂1990年在中国为Game Boy申请的专利（专利号：CN1031376C），从专利中， 可以看到老任画的中文系统框图： 从上面的这些信息，可以说，LR35902的每一寸潜力都被发挥到了极致。 最近，同事从实验室“发掘”了一台产自1995年的HP（没错，就是惠普）的频谱分析仪，也让人不禁感慨，很难想象，早期程序员是如何使用现在看来可以称为是“简陋”的硬件，实现如此复杂的功能。上古程序员简直是披着科技外壳的魔法师。 后续我会更详细的介绍Game Boy的CPU（指令架构等），以及ROM和读卡机制等等，希望这个考古系列能坚持下去。"},{"title":"鸟宿池中树，僧敲月下门：Good Taste in Code","path":"/2018/02/10/鸟宿池中树，僧敲月下门：Good Taste in Code/","content":"作为一个程序员，按时完成业务需求是分内的责任，而作为工程师，我们也应当对代码有美的追求。 Linus在2016年的TED中，举了一个小例子来说明代码品味的问题，C Style的伪代码如下： 12345678910111213141516171819202122remove_list_entry(entry)&#123; prev = NULL; walk = head; // Walk the list while(walk != entry)&#123; prev = walk; walk = walk-&gt;next; &#125; // Remove the entry by updating the // head or previous entry if(!prev) head = entry-&gt;next; else prev-&gt;next = entry-&gt;next;&#125; 12345678910111213141516remove_list_entry(entry)&#123; // The &quot;indirect&quot; pointer points to the // *address* of the thing we&#x27;ll update indirect = &amp;head; // Walk the list, looking for the thing that // points to the entry we want to remove while((*indirect) != entry) indirect = &amp;(*indirect)-&gt;next; // .. and just remove it *indirect = entry-&gt;next;&#125; 两段伪码都是为了实现删除链表中的指定节点。实现同样功能的两段代码，Linus认为第二段更具美感。 Linus:This,the first not very good taste approach,is basically how it’s taught to be done when you start out coding.And you don’t have to understand the code.The most interesting part to me is the last if statement.…… Linus:I don’t want you understand why it doesn’t have the if statement,but I want you to understand that sometimes you can see a problem in a different way and rewrite it so that a special case goes away and becomes the normal case.…… Linus:To me,the sign of people I really want to work with is that they have good taste.…… Linus:I sent you this stupid example that is not relevant because it’s too small.Good taste is much bigger than this.Good taste is about really seeing the big patterns and kind of instinctively knowing what’s the right way to do things.…… 追求代码之美不是为了炫技，我认为所谓“代码之美”，其实就是指代码的稳健、易维护、可复用。在大多数情况下，特别是在紧张的工期中，很难一次性写出高效优雅的代码。代码之美是建立在多次重构之上的，在重构中进步，在进步中重构，逐渐就会锤炼出具有美感的代码。 TED:the Man Behind Linux（Linux背后的男人）"},{"title":"剥洋葱：从RT-Thread的串口到内核对象","path":"/2018/01/04/剥洋葱_从RT-Thread的串口到内核对象/","content":"写在前面：如何阅读和学习一个较大的工程，每个人都有不同的方法。我倾向于首先“不求甚解”地使用API，将整个工程跑起来，对该工程建立一个整体的认识，然后在使用中，从最感兴趣的模块入手，从上层开始，像剥洋葱一样，逐层分析。本文就是按照这样的方法，为研究一个小功能，从RT-Thread 中bsp的串口开始，最终深入到RT-Thread的内核，初步探究内核中的基本元素——内核对象。由于作者手中只有stm32f103的开发板，所以本文在涉及到bsp的代码部分，都是指RT-Thread的github仓库中最新的bsp&#x2F;stm32f10x内的代码。 使用RT-Thread的第一步就是通过ENV工具和scons来构建一个工程。我们可以看到在rtconfig.h中，RT-Thread通过一个宏RT_CONSOLE_DEVICE_NAME（在stm32f10x内，其默认值为“uart1”），就可以完成console所使用串口的设置。这个宏本质就是一个字符串，也就是串口的名字，将这个宏修改为“uart1”，console就会使用串口1。RT-Thread是如何通过串口的名字就可以实际在硬件上控制该串口了呢？ 在stm32f10x的bsp中，main函数内的rtthread_startup()将会完成RT-Thread的初始化。根据代码，整理出与我们此次研究有关的代码层次结构图，如下图所示，在该图中，下级表示被上级调用的子函数，同级之间表示并列关系，即同级的函数都是被上级函数所调用的子函数。 根据上图，我们可以推断出在rt_hw_usart_init中，就完成了字符串（即串口名称）与硬件串口的绑定，所以在接下来调用rt_console_set_device时，就可以直接通过RT_CONSOLE_DEVICE_NAME使用该串口。 下面我们先分析rt_hw_usart_init，其中核心代码的调用结构如下图所示： 串口设备数据结构如下图所示。 从调用层次和串口设备的数据结构中可以发现，RT-Thread将串口封装成一个结构体，其名字（char *name，在stm32f10x中，uart1的名字为“uart1”）最终赋值给结构体子成员的rt_object parent的name数组中。 根据上述分析，当rt_hw_usart_init运行完毕后，串口设备就被注册至内核了。实际上，只是串口设备的“孙”成员（子成员的子成员）rt_object parent，被注册到了内核中。而所谓注册到内核，就是指内核将其地址存入一个链表中。为什么只需要注册其中一个成员呢？这里运用了一个C语言的小技巧，即结构体首个成员的地址就是该结构体的地址，所以当我们获取到了结构体首个成员的地址时，也就相当于我们获取到了该结构体的地址。 下面我们分析rt_console_set_device，其核心代码调用结构如下图所示： 其代码如下所示： 123456789101112131415161718192021222324rt_device_t rt_console_set_device(const char *name)&#123; rt_device_t new, old; /* save old device */ old = _console_device; /* find new console device */ new = rt_device_find(name); if (new != RT_NULL) &#123; if (_console_device != RT_NULL) &#123; /* close old console device */ rt_device_close(_console_device); &#125; /* set new console device */ rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM); _console_device = new; &#125; return old;&#125; 与我们之前的分析一致。rt_console_set_device中维护了一个全局变量_console_device，保存console所使用的串口设备句柄（即串口设备结构体指针）。通过rt_device_find遍历内核中相应的链表，匹配与传入的字符串名称(char *name，在stm32f10x中，默认传入为“uart1”)一致的对象，即可获取到相应的句柄，将其赋值给_console_device，然后console模块就可以通过_console_device控制和使用该串口了。 至此，RT-Thread通过名字就可以控制实际的硬件设备的原理已分析完毕。可以看出，RT-Thread通过分层和对象化思想，将串口封装成了串口——》rt_device——》rt_object的关系，在RT-Thread内核的其他模块中，我们也能大量的发现rt_object和rt_device的身影，这样的封装形式极大的提高了代码的复用率，在RT-Thread中，其派生关系如下图所示。本文分析的串口设备就是一种字符设备。 后记：C语言的对象化和分层思想并不是为了“炫技”和模仿C++，而是为了用最少的代码干最多的事儿，并且减少耦合，更利于大规模的多人开发。Linux、RT-Thread以及其他大的C语言项目中，都运用了这种思想。不论使用什么语言做程序设计，这种思想都是开发大工程的一种最优解（当然这句话在目前“函数式编程”蓬勃发展的情况下显得比较主观）。在阅读优秀的代码时，相比于读懂具体的代码实现，我认为弄清楚为什么要这样实现反而更重要。 本文已被RT-Thread官方公众号“RTThread物联网操作系统”审核通过并发布。"},{"title":"从RT-Thread中我们能学到什么？","path":"/2017/09/02/从RT-Thread中我们能学到什么/","content":"本文将为大家简要介绍一下笔者使用和学习RT-Thread过程中的体会和感悟，希望能帮助初识RT-Thread的人建立一个初步的印象，避免产生入宝山而空回的遗憾。笔者水平有限，目前也正在学习和使用RT-Thread的过程中，希望本文的拙见能抛砖引玉，如有纰漏，还请不吝赐教。 现在是一个快节奏的时代，技术领域也是如此。近些年，IoT备受资本青睐，各种新技术新方案层出不穷，质量也参差不齐，这边唱罢那边登台，以至于有些技术还未被人熟知，就被淹没在长河中了。 客观的说，RTOS领域玩家众多，仅笔者短短的从业时间，国产RTOS就听闻了五、六款之多。 RT-Thread作为一个有十余年历史的国产RTOS，经历了长时间的考验和用户的青睐，目前发展趋势蒸蒸日上，也即将发布RT-Thread 3.0，其中必然有值得我们思考和学习的地方，我们也可以从中汲取到不少宝贵的经验。 软件工程管理 软件工程管理对于软件研发是十分重要的，甚至可以说是开发过程的基石。公司中有高水平的嵌入式软件程序员，也有刚入职的实习生，水平难免参差不齐，当共同协作开发一个项目时，如何彼此协调也是一个难题。 时至今日，很多公司仍然在使用落后的代码管理方式。有些甚至使用把代码压缩成一个个的压缩包来做版本管理。同事之间的协作依靠互相发送文件，每次接收到同事的新文件首先要花半天时间解决编译error，甚至还要在本地对同事的代码进行修改，这样，软件基本处在半失控的状态，某次改动产生问题，就要从浩瀚的压缩包海洋里挑选一个，进行版本回退。在开发一个大项目的时候，这种情况下甚至会出现人数越多，开发难度和周期越大的情况。 而RT-Thread，提供了一个教科书级的范例。 RT-Thread由13000多个文件构成，支持各类设备和芯片近70款，从代码量和组织方式上来说，是一个相当庞大的软件工程。在近十年的时间里，至少有将近100个开发者参与到了RT-Thread的开发中，使得RT-Thread稳步迭代，而这也是有一定的维护难度的。 RT-Thread将代码部署在Github上，并在此基础上使用了Travis CI进行自动化编译测试，使得开发者可以有条不紊的进行迭代开发，并将自己的成果提交至master分支，在提交代码的第一时间通过Travis CI进行自动化编译测试，使得一些无法编译通过的问题，在第一时间就被发现。 使用scons自动化代码构建工具。初识RT-Thread，很难想象RT-Thread通过一个代码仓库，对近70个芯片的IAR、MDK和GCC的工程和工具链提供支持。RT-Thread使用了scons，使得只要敲几行指令，就可以生成所需环境和工具链的对应的工程。也就是说，对于大多数芯片，所谓移植RT-Thread，只需要几个scons指令进行自动化构建。 我相信对于大多数中小公司的软件项目，无论从规模还是参与人数都没有RT-Thread这么庞大，维护难度也小于RT-Thread。但尽管如此，工程维护也是软件工程管理的老大难问题，无疑，从RT-Thread中，我们可以借鉴不少经验。 代码风格与技术 RT-Thread的代码风格是十分优秀的。 在工作中，很多时候嵌入式软件工程师尤其是单片机软件工程师使用的芯片资源相对比较匮乏，RAM和ROM也略显局促，节省资源也成了优先级比较高的事情。而这也成了许多工程师代码不规范的借口。 鲁棒性、模块化、可拓展、高内聚、低耦合，这种高大上的名词总是不绝于耳，相信大家也在各种场景下听过不少次。可抛去这些高大上的名词，到底什么才是优秀的代码呢？ RT-Thread虽然没有强调过这些高大上的名词，但是他毫无疑问用代码对这些名词进行了解释。 RT-Thread的代码风格是类Linux&#x2F;Unix的代码风格。这种风格不仅仅体现在函数、变量的命名规范，而是深入到了RT-Thread的核心。 例如，RT-Thread实现了一个设备驱动框架，将设备类型分为了字符设备、块设备、网络接口设备、内存设备、CAN设备、RTC设备、声音设备、图形设备、I2C总线设备等等等等。初始化时通过字符串（用户可自定义的一个易于记忆的名称）与设备驱动绑定，并将驱动注册到内核，使用时只需调用一个字符串，即可匹配到该设备，无需通过各种头文件包含和二次封装，即可实现隔离和解耦。 RT-Thread提供了finsh和msh组件，可以在调试和开发中进行便捷的交互。 如何在资源紧缺的嵌入式软件开发中，写出优秀的代码，RT-Thread十分值得我们思考和学习。 开源精神 RT-Thread是国内第一梯队的嵌入式开源项目，也正因为开源和社区化，RT-Thread得以茁壮发展，并在开发人员中赢得了极高的口碑，有不小数量的开发者参与到了RT-Thread的开发中。RT-Thread实时操作系统遵循GPLv2+许可证，实时操作系统内核及所有开源组件可以免费在商业产品中使用，不需要公布应用源码，没有任何潜在商业风险。 这种开源精神十分令人钦佩。 得益于RT-Thread的开源，我们可以将自己的代码提交，经过审核后合并至master分支，在使用过程中，当某个模块出现疑问或问题，可以直接与开发者甚至创始人直接进行讨论，这种体验是十分奇妙，也是其他RTOS所不具备的。 RT-Thread倡导大家参与RT-Thread开发的代码编写、bug修复、文档完善等等各项进程中。而实际上一旦自己提交的东西被采纳和合并，也是一件十分有成就感的事情。 我们也可以学习RT-Thread的开源精神，将自己业余时间的代码开源，或者积极参与到开源项目中，在方便大家使用的同时，通过进行更广泛的讨论，也相当于有了更多的人帮助review，接受大家的批评和建议，实现自己更快的进步。 一些思考 现在大家都十分渴望成功，并且渴望快速成功。 在各种融资奇迹下，渐渐地，大家希望，趁着风口，激进地在短时间内完成一款产品，然后借着风口一飞冲天。也渐渐地，失去了精心打磨耕耘一个产品的耐心。 RT-Thread在数千万装机量和获得天使轮近千万融资的背后是十年如一日的细心耕耘和精心呵护。 RT-Thread的创始人熊谱翔先生，起初是在2005年，面对RTOS现状，利用业余时间开发RT-Thread。我想熊谱翔先生的初心也仅仅是想做一款真正优秀的实时操作系统吧。 如同《三傻大闹宝莱坞》中，兰彻达斯所说：“追求卓越，成功就会在不经意间追上你”。 本文已被RT-Thread官方公众号“RTThread物联网操作系统”审核通过并发布。"},{"title":"Hello World","path":"/2017/05/23/Hello_World/","content":"搭建一个这样的简易博客需要什么呢？只需要Github Pages+Hexo，有想法也可以通过Godaddy或者阿里云买一个合适的域名进行绑定（这也是这种方法中唯一需要钱的地方），另外编写文章需要按照MarkDown语法。只要使用”Github Pages””Hexo””搭建博客”等关键字进行搜索，就会找到很多写的不错的教程，国内的oschina（码云）以及coding.net（码市）也提供类似Github Pages的功能，由于众所周知的原因，理论上速度和稳定性与Github Pages相比会更好一些。 其实我还发现了一种堪称葵花宝典的方法:物色一个比较好的用Github Pages搭建的博客，然后直接fork这个项目，然后修改repository name即可，当然不要忘了把博客的内容替换成自己的。具体方法就不详述了，可自行搜索。不过还是建议按照传统的方法一步一步尝试一下，也挺有趣的，后续进行修改，也更为方便。 起初我是有打算租用一个服务器然后一键部署WordPress，后来翻了一下钱包，就打消了这个念头lol。 以后会在这里写一些闲言碎语，并计划把自己的一部分代码放在Github上，希望能够产生些许价值。 由于暂时不支持评论，如有需要，请联系&#x62;&#x75;&#112;&#x6c;&#101;&#117;&#x72;&#x75;&#109;&#x40;&#x6f;&#117;&#x74;&#x6c;&#x6f;&#111;&#x6b;&#46;&#x63;&#x6f;&#x6d;。 由于多说即将暂停服务，最终决定使用Gitalk 提供评论功能，目前已支持评论。请您登陆Github进行评论，目前评论必须登陆Github，如有不便，请您谅解。"}]